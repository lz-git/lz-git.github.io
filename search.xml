<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谷粒商城项目day01 linux上安装docker配置mysql和redis</title>
      <link href="/2020/08/11/java-dui-xiang-wei-sha-yao-shi-xian-serializable-jie-kou/"/>
      <url>/2020/08/11/java-dui-xiang-wei-sha-yao-shi-xian-serializable-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="Java对象为啥要实现Serializable接口？"><a href="#Java对象为啥要实现Serializable接口？" class="headerlink" title="Java对象为啥要实现Serializable接口？"></a>Java对象为啥要实现Serializable接口？</h2><h3 id="Serializable接口概述"><a href="#Serializable接口概述" class="headerlink" title="Serializable接口概述"></a><strong>Serializable接口概述</strong></h3><p>Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。</p><p>而这一点对于面向对象的编程语言来说是非常重要的，因为无论什么编程语言，其底层涉及IO操作的部分还是由操作系统其帮其完成的，而底层IO操作都是以字节流的方式进行的，所以写操作都涉及将编程语言数据类型转换为字节流，而读操作则又涉及将字节流转化为编程语言类型的特定数据类型。而Java作为一门面向对象的编程语言，对象作为其主要数据的类型载体，为了完成对象数据的读写操作，也就需要一种方式来让JVM知道在进行IO操作时如何将对象数据转换为字节流，以及如何将字节流数据转换为特定的对象，而Serializable接口就承担了这样一个角色。</p><p>下面我们可以通过例子来实现将序列化的对象存储到文件，然后再将其从文件中反序列化为对象，代码示例如下：</p><p>先定义一个序列化对象User：</p><pre class=" language-JAVA"><code class="language-JAVA">public class User implements Serializable &#123;     private static final long serialVersionUID = 1L;     private String userId;     private String userName;     public User(String userId, String userName) &#123;         this.userId = userId;         this.userName = userName;     &#125; &#125; </code></pre><p>然后我们编写测试类，来对该对象进行读写操作，我们先测试将该对象写入一个文件：</p><pre class=" language-JAVA"><code class="language-JAVA">public class SerializableTest &#123;     /**      * 将User对象作为文本写入磁盘      */     public static void writeObj() &#123;         User user = new User("1001", "Joe");         try &#123;             ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("/Users/guanliyuan/user.txt"));             objectOutputStream.writeObject(user);             objectOutputStream.close();         &#125; catch (IOException e) &#123;             e.printStackTrace();         &#125;     &#125;     public static void main(String args[]) &#123;         writeObj();     &#125; &#125; </code></pre><p>运行上述代码，我们就将User对象及其携带的数据写入了文本user.txt中，我们可以看下user.txt中存储的数据此时是个什么格式：</p><pre class=" language-JAVA"><code class="language-JAVA">java.io.NotSerializableException: cn.wudimanong.serializable.User     at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)     at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)     at cn.wudimanong.serializable.SerializableTest.writeObj(SerializableTest.java:19)     at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:27) </code></pre><p>我们看到对象数据以二进制文本的方式被持久化到了磁盘文件中。在进行反序列化测试之前，我们可以尝试下将User实现Serializable接口的代码部分去掉，看看此时写操作是否还能成功，结果如下：</p><p>结果不出所料，果然是不可以的，抛出了NotSerializableException异常，提示非可序列化异常，也就是说没有实现Serializable接口的对象是无法通过IO操作持久化的。</p><p>接下来，我们继续编写测试代码，尝试将之前持久化写入user.txt文件的对象数据再次转化为Java对象，代码如下：</p><pre class=" language-JAVA"><code class="language-JAVA">public class SerializableTest &#123;     /**      * 将类从文本中提取并赋值给内存中的类      */     public static void readObj() &#123;         try &#123;             ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("/Users/guanliyuan/user.txt"));             try &#123;                 Object object = objectInputStream.readObject();                 User user = (User) object;                 System.out.println(user);             &#125; catch (ClassNotFoundException e) &#123;                 e.printStackTrace();             &#125;         &#125; catch (IOException e) &#123;             e.printStackTrace();         &#125;     &#125;     public static void main(String args[]) &#123;         readObj();     &#125; &#125; </code></pre><p>通过反序列化操作，可以再次将持久化的对象字节流数据通过IO转化为Java对象，结果如下：</p><pre class=" language-JAVA"><code class="language-JAVA">cn.wudimanong.serializable.User@6f496d9f </code></pre><p>此时，如果我们再次尝试将User实现Serializable接口的代码部分去掉，发现也无法再文本转换为序列化对象，报错信息为：</p><pre class=" language-JAVA"><code class="language-JAVA">ava.io.InvalidClassException: cn.wudimanong.serializable.User; class invalid for deserialization     at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:157)     at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:862)     at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2038)     at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568)     at java.io.ObjectInputStream.readObject(ObjectInputStream.java:428)     at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:31)     at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:44) </code></pre><p>提示非法类型转换异常，说明在Java中如何要实现对象的IO读写操作，都必须实现Serializable接口，否则代码就会报错!</p><h3 id="序列化-amp-反序列化"><a href="#序列化-amp-反序列化" class="headerlink" title="序列化&amp;反序列化"></a><strong>序列化&amp;反序列化</strong></h3><p>通过上面的阐述和示例，相信大家对Serializable接口的作用是有了比较具体的体会了，接下来我们上层到理论层面，看下到底什么是序列化/反序列化。序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。</p><p>而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。那么什么情况下需要序列化呢?大概有这样两类比较常见的场景：1)、需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时;2)、网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时;</p><h3 id="关于serialVersionUID"><a href="#关于serialVersionUID" class="headerlink" title="关于serialVersionUID"></a><strong>关于serialVersionUID</strong></h3><p>对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID，如：</p><pre class=" language-JAVA"><code class="language-JAVA">private static final long serialVersionUID = 1L; </code></pre><p>在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的serialVersionUID与对应持久化时的类不同，那么反序列化的过程中将会导致InvalidClassException异常。例如，在之前反序列化的例子中，我们故意将User类的serialVersionUID改为2L，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2L<span class="token punctuation">;</span> </code></pre><p>那么此时，在反序例化时就会导致异常，如下：</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InvalidClassException<span class="token operator">:</span> cn<span class="token punctuation">.</span>wudimanong<span class="token punctuation">.</span>serializable<span class="token punctuation">.</span>User<span class="token punctuation">;</span> local <span class="token keyword">class</span> <span class="token class-name">incompatible</span><span class="token operator">:</span> stream classdesc serialVersionUID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> local <span class="token keyword">class</span> <span class="token class-name">serialVersionUID</span> <span class="token operator">=</span> <span class="token number">2</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectStreamClass<span class="token punctuation">.</span><span class="token function">initNonProxy</span><span class="token punctuation">(</span>ObjectStreamClass<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">687</span><span class="token punctuation">)</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">.</span><span class="token function">readNonProxyDesc</span><span class="token punctuation">(</span>ObjectInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1880</span><span class="token punctuation">)</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">.</span><span class="token function">readClassDesc</span><span class="token punctuation">(</span>ObjectInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1746</span><span class="token punctuation">)</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">.</span><span class="token function">readOrdinaryObject</span><span class="token punctuation">(</span>ObjectInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2037</span><span class="token punctuation">)</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">.</span><span class="token function">readObject0</span><span class="token punctuation">(</span>ObjectInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1568</span><span class="token punctuation">)</span>     at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">428</span><span class="token punctuation">)</span>     at cn<span class="token punctuation">.</span>wudimanong<span class="token punctuation">.</span>serializable<span class="token punctuation">.</span>SerializableTest<span class="token punctuation">.</span><span class="token function">readObj</span><span class="token punctuation">(</span>SerializableTest<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">31</span><span class="token punctuation">)</span>     at cn<span class="token punctuation">.</span>wudimanong<span class="token punctuation">.</span>serializable<span class="token punctuation">.</span>SerializableTest<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>SerializableTest<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">44</span><span class="token punctuation">)</span> </code></pre><p>如果我们在序列化中没有显示地声明serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的serialVersionUID值。但是，Java官方强烈建议所有要序列化的类都显示地声明serialVersionUID字段，因为如果高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。因此，为了保证跨不同Java编译器实现的serialVersionUID值的一致，实现Serializable接口的必须显示地声明serialVersionUID字段。</p><p>此外serialVersionUID字段地声明要尽可能使用private关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!有个特殊的地方需要注意的是，数组类是不能显示地声明serialVersionUID的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配serialVersionUID值的要求。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城项目day01 linux上安装docker配置mysql和redis</title>
      <link href="/2020/08/09/gu-li-shang-cheng-xiang-mu/"/>
      <url>/2020/08/09/gu-li-shang-cheng-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="谷粒商城项目"><a href="#谷粒商城项目" class="headerlink" title="谷粒商城项目"></a>谷粒商城项目</h2><h4 id="docker安装mysql"><a href="#docker安装mysql" class="headerlink" title="docker安装mysql"></a>docker安装mysql</h4><ol><li><p>用docker安装上mysql，去docker仓库里搜索mysql</p><pre class=" language-docker"><code class="language-docker">sudo docker pull mysql<span class="token punctuation">:</span>5.7<span class="token comment" spellcheck="true"># --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行</span>sudo docker run <span class="token punctuation">-</span>p 3306<span class="token punctuation">:</span>3306 <span class="token punctuation">-</span><span class="token punctuation">-</span>name mysql \<span class="token punctuation">-</span>v /mydata/mysql/log<span class="token punctuation">:</span>/var/log/mysql \<span class="token punctuation">-</span>v /mydata/mysql/data<span class="token punctuation">:</span>/var/lib/mysql \<span class="token punctuation">-</span>v /mydata/mysql/conf<span class="token punctuation">:</span>/etc/mysql \<span class="token punctuation">-</span>e MYSQL_ROOT_PASSWORD=root \<span class="token punctuation">-</span>d mysql<span class="token punctuation">:</span>5.7</code></pre></li><li><p>进入mysql容器</p><pre class=" language-docker"><code class="language-docker">docker exec <span class="token punctuation">-</span>it mysql /bin/bash </code></pre></li><li><p>查看mysql装在哪里</p><pre class=" language-docker"><code class="language-docker">whereis mysql</code></pre></li><li><p>退出mysql容器 后台运行</p><pre class=" language-docker"><code class="language-docker">ctrl + p + q或 exit</code></pre></li><li><p>修改mysql的配置文件只要修改root下的/mydata/mysql/conf就好</p><pre class=" language-mysql"><code class="language-mysql">cd /mydata/mysql/confvi my.cnf[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect='SET collation_connection = utf8_unicode_ci'init_connect='SET NAMES utf8'character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve保存(注意评论区该配置不对，不是collection而是collation)docker restart mysql</code></pre></li><li><p>查看容器内配置文件是否存在</p><pre class=" language-mysql"><code class="language-mysql">docker exec -it mysql /bin/bashcd /etc/mysql发现有刚创建的my.cnf</code></pre></li></ol><h4 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h4><ol><li><p>如果直接挂载的话docker会以为挂载的是一个目录，所以我们先创建一个文件然后再挂载，在虚拟机中。</p><pre class=" language-mysql"><code class="language-mysql"># 在虚拟机中mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.confdocker pull redisdocker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \-d redis redis-server /etc/redis/redis.conf  #每次启动服务端加载配置文件# 直接进去redis客户端。docker exec -it redis redis-cli</code></pre></li><li><p>测试redis客户端</p><pre class=" language-mysql"><code class="language-mysql">docker exec -it redis redis-cliset a bget a</code></pre></li><li><p>默认是不持久化的。在配置文件中输入appendonly yes，就可以aof持久化了。修改完docker restart redis，docker -it redis redis-cli</p><pre class=" language-mysql"><code class="language-mysql">vim /mydata/redis/conf/redis.conf# 插入下面内容appendonly yes保存docker restart redis</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
          <category> mysql </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
            <tag> mysql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础命令</title>
      <link href="/2020/08/09/linux-ji-chu-ming-ling/"/>
      <url>/2020/08/09/linux-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul><li>ls: 列出目录      ls /  查看根路径root下的目录</li><li>cd：切换目录  </li><li>cd .. :切换到上级目录</li><li>cd ~ : 切换到根目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li><p>touch f1.java :创建文件</p></li><li><p>clear :清屏</p></li><li><p>cat 文件名 : 查看文件</p></li><li><p>nl 文件名 :查看文件并显示行号</p></li><li><p>more 文件名 :查看文件一页一页翻动 </p></li><li><p>ctrl + c :退出文件查看</p></li></ul><h3 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h3><ul><li><p>vim kuangstudy.txt ：进入vim编辑  </p><p>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</p><p>编辑好后按下 ESC 按钮回到指令模式</p><p> :wq! 则为强制储存后离开 (常用)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/08/07/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2020/08/07/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="欢迎大家来到我的博客，以后有什么问题可以一起交流学习。"><a href="#欢迎大家来到我的博客，以后有什么问题可以一起交流学习。" class="headerlink" title="欢迎大家来到我的博客，以后有什么问题可以一起交流学习。"></a>欢迎大家来到我的博客，以后有什么问题可以一起交流学习。</h2><p>​        很多孩子在幼年时期有着波澜壮阔的梦想，却最终活成了最普通的模样。他们做着普通的工作，过着普通的生活，没有出类拔萃，没有万众瞩目，甚至儿时的一点天赋与灵气，也已经在人生的风雨与岁月的磨砺中泯然于众。但是，这个世界不是只有星光最亮的星星才值得挂在天上。每个人都是一颗独一无二的星辰，站在自己的位置，发着自己的光。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 机械设计 </category>
          
          <category> 剪辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> css </tag>
            
            <tag> spring </tag>
            
            <tag> 机械设计 </tag>
            
            <tag> 剪辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/07/hello-world/"/>
      <url>/2020/08/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
